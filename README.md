# server uses python

# site uaess Webpack + TypeScript + React
## Install build tools
npm install -g webpack webpack-cli

# Before build
npm update

# site address
http://localhost:5000/

# Project structure
project-root/
├── server/                   # Python HTTP server
│   ├── [<...>.py]            # Python code of the server
│   ├── requirements.txt      # Python dependencies
│   └── Dockerfile            # Container for the Python server
├── site/                     # TypeScript/HTML app
│   ├── src/
│   │   └── [...]             # TypeScript code of the site
│   ├── public/               # Static assets (HTML, CSS, images)
│   ├── package.json
│   ├── tsconfig.json
│   ├── webpack.config.js
│   └── Dockerfile            # Build container for the client
├── docker-compose.yml        # Compose file to run both services together
└── .gitignore                # Exclude build artifacts, node_modules, etc.


# labirinth
labirinth projects

/**
 * Лабиринт - это матрица ячеек M x N.
 * Между соседними по вертикали или горизонтили ячейками может быть разрешен или запрещен переход.
 * Если из одной ячейки можно путем последовательных переходов перейти в другую ячейку, то значит между этими двумя ячейками есть путь.
 * Цель: сгенерировать Лабиринт, в котором был бы один и только один путь между любыми двумя ячейками,
 * в котором нет возвратов (возврат - пара путей между двумя ячейками, которые отличаются только направлениями).
 * 
 * Основная идея реализации:
 * Лабиринт описывается ненаправленным графом, в котором ячейки лабиринта - это вершины графа,
 * а переходы (заперщенные и разрешенные) - это ребра.
 * В этом случае цель достигается, когда сгенерирован ацикличный связный граф.
 * 1. создать граф лабиринта, в котором все переходы разрешены;
 * 2. запретить случайный переход;
 * 3. сделать обход графа:
 * 3.1. перейти в следующую вершину графа;
 * 3.2. если вершина уже есть в списке посещенных вершин, значит граф цикличный, запретить этот переход и вернуться к предыдущей вершине и перейти в 3.7;
 * 3.3. добавить вершину, в список посещенных вершин;
 * 3.4. случайным образом выбрать следующий разрешенный переход из этой вершины;
 * 3.5. если есть следующая разрешенный переход, то перейти в 3.1;
 * 3.6. если разрешенных переходов нет, то вернуться к предыдущей вершине;
 * 3.7. если есть предыдущая вершина, то перейти к 3.4;
 * 3.8. если предыдущих вершин нет, то обход завершен;
 * 3.9. если количество посещенных вершин равно количеству вершин графа, то граф связный;
 **/
